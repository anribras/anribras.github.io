---
layout: post
title:
modified:
categories: Tech
tags: [javascript,web]
comments: true
---
<!-- TOC -->

- [总览](#总览)
- [交互jsbrige](#交互jsbrige)
    - [当前实现](#当前实现)
    - [值得借鉴1](#值得借鉴1)
    - [值得借鉴2](#值得借鉴2)
- [优化方向](#优化方向)

<!-- /TOC -->

## 总览

目前阶段，web页面是辅助native.如一些2级页面，产品页等等.

技术栈
```sh
h5:Vue + Native: Webview
single view混合hybrid app;(页面要么是h5,要么是native)
```
应该是属于最简单的那种了,不过都是依据团队现状和能力来选择的.

## 交互jsbrige

### 当前实现
有单向:
```sh
beNotifedLogin
startViewxxx
```
也有双向的需求:
```sh
beNotifiedToken -> setToken
beNotifiedComment -> postComment
beNotifiedScroollToComment ->scrollToComment
```
双向的是可以考虑用callback方式优化的.

* js->native
native注入api, api名称区分功能. js调用时, 可以传不同的args到native.
```js
function inner(functionName, args) {
  args = ((typeof (args) === 'object' && args )  ? JSON.stringify(args) : args);
  try {
    if (isAndroid) {
      if(args) window.android[functionName](args);
      else window.android[functionName]();
    }
    if (isIOS) window.webkit.messageHandlers[functionName].postMessage(args);
  } catch (e) {
    // alert(e);
    console.log('catch jsb: ' + functionName)
  }
}
startReservation: function (args = null) {
    inner('startReservation', args)
},
```


* native->js
直接把callback方法挂在了window上，想回调就调, 当然没啥封装性可言..怎么方便怎么来
```js
window.someMethod(...) {
}
```


### 值得借鉴1

<https://zhuanlan.zhihu.com/p/32899522>

封装的还行.

native->js native注入,js到native则是通过配套的callback.

callback是通过1个eventMap保存在jsBridge对象里,最终也是把这个对象抛给了native.

native执行callback时，在jsBrige.eventMap里找对应的闭包并执行:

```js
eventMap: {
  'someMethod': function(data) {  callback && callback(data);}
}
```

### 值得借鉴2

<https://segmentfault.com/a/1190000015678155>

1是url schema来通讯,个人感觉不如注入.

2是把bridge js实现部分和native实现部分封装在native sdk里,然后webview异步注入bridge.js后方可使用bridge功能.

h5不关心bridge的实现,更独立. 


## 优化方向

自然是走纯粹的spa了.



