---
layout: post
title:
modified:
categories: Tech
tags: [cplusplus]
comments: true
---

<!-- TOC -->

- [IO](#io)
- [容器](#容器)
    - [通用特性](#通用特性)
        - [迭代器](#迭代器)
            - [额外的iterator](#额外的iterator)
            - [迭代器类别划分](#迭代器类别划分)
        - [左闭右合的设计](#左闭右合的设计)
        - [赋值与swap](#赋值与swap)
        - [> = <](#--)
    - [顺序容器](#顺序容器)
        - [添加](#添加)
        - [访问](#访问)
        - [删除](#删除)
        - [farward_list特殊](#farward_list特殊)
            - [insert_after](#insert_after)
            - [before_begin](#before_begin)
    - [容器适配器](#容器适配器)
    - [关联容器](#关联容器)
    - [无序容器](#无序容器)
- [泛型算法](#泛型算法)
    - [插入元素](#插入元素)
    - [算法形参](#算法形参)
    - [算法谓词](#算法谓词)
    - [特定容器算法](#特定容器算法)

<!-- /TOC -->


# IO

![Screenshot from 2019-05-24 17-40-36-f8eb045f-7bff-4c0d-98b9-9dfa882ede97](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-24%2017-40-36-f8eb045f-7bff-4c0d-98b9-9dfa882ede97.png)

终端：istream,ostream,iostream
文件: ifstream,ostream,iofstream;
string: istringstream,ostringstream,iostringstream;

# 容器

容器本身就是对聚合数据结构的一种封装, 数据结构的值类型有模板具体化时指定.

## 通用特性
![Screenshot from 2019-05-25 09-59-18-baa7c927-452f-49b7-80ab-57582650f03f](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2009-59-18-baa7c927-452f-49b7-80ab-57582650f03f.png)
![Screenshot from 2019-05-25 09-59-46-a00c8972-e9fb-4a87-8c4b-3cef6d45751f](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2009-59-46-a00c8972-e9fb-4a87-8c4b-3cef6d45751f.png)
![Screenshot from 2019-05-25 10-00-05-e91b64bf-aa3c-4c33-8d14-8214f141c500](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2010-00-05-e91b64bf-aa3c-4c33-8d14-8214f141c500.png)

### 迭代器
就是`迭代器模式`的实现:提供１种方法(这里是迭代器类),顺序访问聚合对象，不同于直接访问，他通过封装的方法访问，不会暴露聚合对象的内部表示.

从外部看，迭代器就代表了那个对象.

迭代器和智能指针有类似的地方，都是pimple模式的具体实现,核心是那个指针.

* 和容器的关系?　当具体化了１个container:
可以得到迭代器的具体定义类型,vector<int>::iteraotr
原理是:
```cpp
class A {
public:
	typedef int my_type ; 
};
```
真正的迭代器对象，则要通过api返回，无法直接得到，
如`auto iter = veci.begin()`为何只能通过方法?
背后的实现应该是
```
//vector.h
class Vector: public Iterator {
private:
    data_structure some_data_elem[100];
}
//vector.cpp
//Iterator可能是抽象类，定义了纯虚方法begin.
template<typename Elem>
const Iterator & Vector::begin() {
    //必然需要保存begin代表的index,0
    //实际上使用指针来做的
}
private:
    //维护１个元素类型的指针
    Elem* ptr;
}
```

#### 额外的iterator
* insert iterator
*it即写值
front_inserter　执行了push_front
back_inserter 执行了push_back
inserter 执行了insert
make_move_iterator: 剪切
* stream iterator
用来处理io，绑定steam.
操作容器就完成数据流io的进出，非常重要的思想!

假设做web处理,接收json:
```
传输的是json序列化后的原始字符串;
str流用stringstream收;
stringstream绑定到istreamer_iterator<Json> iter;
将iter初始化到vector<Json> vecj;
vecj.push_back(*iter)就可以接收json数据
```
```cpp
istream_iterator<int>  cin_it(cin);
istream_iterator<int>  cin_eof;
vector<int> veci(cin_it, cin_eof);
//压入元素,来的isteam_iteator, 等待输入,
//1个push_back通过iterator在阻塞等待
//精妙的封装
//
veci.push_back(*cin_it);
```
* reverse iterator
* move iterator

#### 迭代器类别划分


这是根本的迭代器类别划分，不同类别的功能不一,上面的说的各种iteratoer,
都属于其中某一类:

![Screenshot from 2019-05-26 08-09-11-e8ca9100-d91c-4bee-8dfd-71f3d79356d2](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-26%2008-09-11-e8ca9100-d91c-4bee-8dfd-71f3d79356d2.png)

如vector,string,deque的迭代器都是随机访问iterator.
farward_list里是前向iterator.
list里是双向iterator.

stl find要去用Input Iterator:
```cpp
template<class InputIterator, class T>
  InputIterator find (InputIterator first, InputIterator last, const T& val)
{
  while (first!=last) {
    if (*first==val) return first;
    ++first;
  }
  return last;
}
```
copy需要InputIterator和OutputItertor:
```cpp
template<class InputIterator, class OutputIterator>
  OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result)
{
  while (first!=last) {
    *result = *first;
    ++result; ++first;
  }
  return result;
}
```


### 左闭右合的设计
[begin,end)
如果一开始begin == end,容器为空;
否则如果不空，while(begin != end) { begin ++} 直到 begin==end, 迭代完成.

右开意味着c.end()返回的iter是最后1个元素的尾后:
```cpp
std::vector<int> vec1 = {1,2,3};
std::vector<int> vec2 = {4,5,6};
//insert
auto end = vec1.end();
//end指向尾后，最后1个元素应该往前挪
assert( vec1.back() == *(end-1 ) ) ;
```

### 赋值与swap
构造, emplace,assign, swap.
assign仅适用顺序容器.
swap仅交换指针，参考之前的高效swap实现.
```cpp
list<string> names;
vector<const char*> other;
name = other ;// no 不相容
name.assign(begin(other),begin(other)+5);
```

### > = <
长度和元素相等则相等
begin开始的子序列，第1个不等的，谁大，容器就大;


## 顺序容器

顺序访问能力: iter++, iter--, iter[] ,不一定都支持.

![Screenshot from 2019-05-24 17-52-45-67bbb782-d756-42f3-9f2e-503b13b8f18e](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-24%2017-52-45-67bbb782-d756-42f3-9f2e-503b13b8f18e.png)

vector,string  连续内存，即数组 ,缺点中间插入慢　
list: 双向链表, 怎么插都快，但是不能随机访问;
forward_list: 单向链表,　小而美
deque: 双端队列，随机访问快，两端增删也很快，中间插入慢，数据结构比较特殊,采用了`分段连续线性空间`,
<https://blog.csdn.net/baidu_28312631/article/details/48000123> 

感觉deque比vector好？多了push_front,数据结构本身要复杂，非线性存储，随机访问肯定不如vector.

看问题是多大规模的: 如小规模，又需要push_front的deque.
怎么确定规模？看具体问题,跑个benchmark.

### 添加

insert,push_back,emplace_back,push_front.
1. 结合各自的特性,有的支持，有的不支持
2. 添加元素的本质是copy,考虑性能代价的话，最好在容器里放指针.
3. insert有多个版本

![Screenshot from 2019-05-25 11-23-57-05631dab-fe81-4160-88f1-3c47deb2197b](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2011-23-57-05631dab-fe81-4160-88f1-3c47deb2197b.png)

### 访问
1类是操作符: ++,-- +n, -n *iter

1类是成员函数:at, back,front,包括[],成员函数返回的是引用.
```cpp
c.front() = 42; //ok
auto & v = c.back();
auto v = c.back();//这里发生了拷贝.
```
![Screenshot from 2019-05-25 13-22-37-2cd69ec7-02a8-482b-8188-7a0ca69e7a2e](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2013-22-37-2cd69ec7-02a8-482b-8188-7a0ca69e7a2e.png)
### 删除
pop_front().pop_back(),erase,clear.
![Screenshot from 2019-05-25 13-22-20-2ca28b4d-860b-4127-bd37-af77ed0f3ee2](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2013-22-20-2ca28b4d-860b-4127-bd37-af77ed0f3ee2.png)


### farward_list特殊

#### insert_after
顺序容器insert都是insert_before，但是单链表无法实现，只能insert_after.
![Screenshot from 2019-05-25 13-38-31-3ea33970-2900-473e-8c64-9336156af1dd](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2013-38-31-3ea33970-2900-473e-8c64-9336156af1dd.png)
#### before_begin
为何需要?因为只实现了insert_after,那得知道after谁把，就是这个before_begin.
```cpp
std::forward_list<int> flst = {1,2,3,4,5,6,7};
//如何插入到头部，又只有insert_after? 用before_begin
auto pos = flst.before_begin();
flst.insert_after(pos,0);
for_each(begin(flst),end(flst),[](const int & i){cout << i << " ";});
std::out << std::endl;
```

## 容器适配器

适配顺序容器，完成更高级的数据结构功能.

stack: 栈，可接受 list deque, vector,
queue: FIFO,可接收: list deque (vector不支持push_front)
priority_queue: 最大最小堆, 可接受vector deque,　(list不支持随机访问)

## 关联容器

关联容器是按关键字来保存和访问数据的.

不支持位置相关的操作, xx_back,xx_front，它没有头和尾的概念.


(key)有序: set, multiset, map, multimap, 
(key)无序:unordered_set,unordered_multiset,unordered_map,unordered_multimap


有序是指key在遍历时是排序的，是因为在key上定义了默认的`<`操作符，


## 无序容器

set,map

# 泛型算法

algorithm.h.

算法会利用容器迭代器的访问性质([],++.--等)，而不会操作(添加、删除)容器,因此算法不会改变底层容器的大小,但是可以改动值

为何不操作?因为操作没法用algorithm统一,需要针对不同容器用不同的algorithm.

算法都是对某个范围内的元素操作，分3类:
```
只读，只读取容器；
改变,　改变元素到新的容器里
重排.
```

## 插入元素

一定要插入元素，怎么办?
前面说了算法只访问容器，但不操作,比如push_back;
back_inserter就是打破这个，它接收１个容器，返回1个迭代器，当对迭代器赋值时，实际就是push_back元素到容器里:
```
vector<int> veci;// 空vec
fill_n(begin(veci),10,1);//错误,veci没有元素.
fill_n(back_inserter(veci),10,1); ok
```

## 算法形参
![Screenshot from 2019-05-26 08-37-06-73174a61-05ec-42be-b451-f3ec1c795504](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-26%2008-37-06-73174a61-05ec-42be-b451-f3ec1c795504.png)


## 算法谓词

什么是`谓词`?
2 大于1 , 3不是4, 5是5,中间按个词，就是算法的谓词，用１个函数表示，可接收1个or2个参数，参数类型等于输入算法的iterator的元素类型.

部分算法支持谓词,比如sort, xx_if

```cpp
sort(begin,end,pred);
find(begin,end,val);
find_if(begin,end,pred);
```

谓词函数可用普通函数，可用lamdba表达式
```cpp
//显示定义尾置指针类型，即指定lamdba的返回类型
transform(begin(v),end(v),begin(o),[](const int & i)->int {
    if(i) return -i; else return i; });

//ok
transform(begin(v),end(v),begin(o),[](const int & i) { 
    return i>0? i:-i;});
//fail 推断lambda返回为void
transform(begin(v),end(v),begin(o),[](const int & i) { 
    if(i) return -i; else return i; });
```

## 特定容器算法

主要是list,为了性能为更好,和普通算法不同，可能改变list容器.

![Screenshot from 2019-05-26 08-41-31-4d8ca99c-2a3d-4eec-96e8-39707e4b46bb](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-26%2008-41-31-4d8ca99c-2a3d-4eec-96e8-39707e4b46bb.png)

![Screenshot from 2019-05-26 08-43-53-6be6d710-0dfa-4396-8a55-8cd7ff0c174f](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-26%2008-43-53-6be6d710-0dfa-4396-8a55-8cd7ff0c174f.png)