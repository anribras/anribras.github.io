---
layout: post
title:
modified:
categories: Tech
tags: [c++]
comments: true
---

<!-- TOC -->

- [IO](#io)
- [容器](#容器)
    - [通用特性](#通用特性)
        - [迭代器](#迭代器)
        - [左闭右合的设计](#左闭右合的设计)
        - [赋值与swap](#赋值与swap)
        - [> = <](#--)
    - [顺序容器](#顺序容器)
        - [添加](#添加)
        - [访问](#访问)
        - [删除](#删除)
        - [farward_list特殊](#farward_list特殊)
            - [insert_after](#insert_after)
            - [before_begin](#before_begin)
    - [关联容器](#关联容器)
    - [无序容器](#无序容器)

<!-- /TOC -->


# IO

![Screenshot from 2019-05-24 17-40-36-f8eb045f-7bff-4c0d-98b9-9dfa882ede97](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-24%2017-40-36-f8eb045f-7bff-4c0d-98b9-9dfa882ede97.png)

终端：istream,ostream,iostream
文件: ifstream,ostream,iofstream;
string: istringstream,ostringstream,iostringstream;

# 容器

容器本身就是对聚合数据结构的一种封装, 数据结构的值类型有模板具体化时指定.

## 通用特性
![Screenshot from 2019-05-25 09-59-18-baa7c927-452f-49b7-80ab-57582650f03f](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2009-59-18-baa7c927-452f-49b7-80ab-57582650f03f.png)
![Screenshot from 2019-05-25 09-59-46-a00c8972-e9fb-4a87-8c4b-3cef6d45751f](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2009-59-46-a00c8972-e9fb-4a87-8c4b-3cef6d45751f.png)
![Screenshot from 2019-05-25 10-00-05-e91b64bf-aa3c-4c33-8d14-8214f141c500](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2010-00-05-e91b64bf-aa3c-4c33-8d14-8214f141c500.png)

### 迭代器
就是`迭代器模式`的实现:提供１种方法(这里是迭代器类),顺序访问聚合对象，不同于直接访问，他通过封装的方法访问，不会暴露聚合对象的内部表示.

从外部看，迭代器就代表了那个对象.

### 左闭右合的设计
[begin,end)
如果一开始begin == end,容器为空;
否则如果不空，while(begin != end) { begin ++} 直到 begin==end, 迭代完成.

右开意味着c.end()返回的iter是最后1个元素的尾后:
```cpp
std::vector<int> vec1 = {1,2,3};
std::vector<int> vec2 = {4,5,6};
//insert
auto end = vec1.end();
//end指向尾后，最后1个元素应该往前挪
assert( vec1.back() == *(end-1 ) ) ;
```

### 赋值与swap
构造, emplace,assign, swap.
assign仅适用顺序容器.
swap仅交换指针，参考之前的高效swap实现.
```cpp
list<string> names;
vector<const char*> other;
name = other ;// no 不相容
name.assign(begin(other),begin(other)+5);
```

### > = <
长度和元素相等则相等
begin开始的子序列，第1个不等的，谁大，容器就大;


## 顺序容器

顺序访问能力: iter++, iter--, iter[] ,不一定都支持.

![Screenshot from 2019-05-24 17-52-45-67bbb782-d756-42f3-9f2e-503b13b8f18e](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-24%2017-52-45-67bbb782-d756-42f3-9f2e-503b13b8f18e.png)

vector,string  连续内存，即数组 ,缺点中间插入慢　
list: 双向链表, 怎么插都快，但是不能随机访问;
forward_list: 单向链表,　小而美
deque: 双端队列，随机访问快，两端增删也很快，中间插入慢，数据结构比较特殊,采用了`分段连续线性空间`,
<https://blog.csdn.net/baidu_28312631/article/details/48000123> 

感觉deque比vector好？多了push_front,数据结构本身要复杂，非线性存储，随机访问肯定不如vector.

看问题是多大规模的: 如小规模，又需要push_front的deque.
怎么确定规模？看具体问题,跑个benchmark.

### 添加

insert,push_back,emplace_back,push_front.
1. 结合各自的特性,有的支持，有的不支持
2. 添加元素的本质是copy,考虑性能代价的话，最好在容器里放指针.
3. insert有多个版本

![Screenshot from 2019-05-25 11-23-57-05631dab-fe81-4160-88f1-3c47deb2197b](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2011-23-57-05631dab-fe81-4160-88f1-3c47deb2197b.png)

### 访问
1类是操作符: ++,-- +n, -n *iter

1类是成员函数:at, back,front,包括[],成员函数返回的是引用.
```cpp
c.front() = 42; //ok
auto & v = c.back();
auto v = c.back();//这里发生了拷贝.
```
![Screenshot from 2019-05-25 13-22-37-2cd69ec7-02a8-482b-8188-7a0ca69e7a2e](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2013-22-37-2cd69ec7-02a8-482b-8188-7a0ca69e7a2e.png)
### 删除
pop_front().pop_back(),erase,clear.
![Screenshot from 2019-05-25 13-22-20-2ca28b4d-860b-4127-bd37-af77ed0f3ee2](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2013-22-20-2ca28b4d-860b-4127-bd37-af77ed0f3ee2.png)


### farward_list特殊

#### insert_after
顺序容器insert都是insert_before，但是单链表无法实现，只能insert_after.
![Screenshot from 2019-05-25 13-38-31-3ea33970-2900-473e-8c64-9336156af1dd](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-25%2013-38-31-3ea33970-2900-473e-8c64-9336156af1dd.png)
#### before_begin


## 关联容器

## 无序容器

set,map
