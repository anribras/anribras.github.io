---
layout: post
title:
modified:
categories: Tech
tags: [c++]
comments: true
---
<!-- TOC -->

- [要点](#要点)
    - [类型提升规则](#类型提升规则)
    - [引用与const引用](#引用与const引用)
    - [c++11 constexpr](#c11-constexpr)
    - [const修饰的位置](#const修饰的位置)
    - [struct 与class区别](#struct-与class区别)
    - [auto](#auto)
    - [decltype](#decltype)
    - [c++11 委托构造函数](#c11-委托构造函数)
    - [c++初始化列表](#c初始化列表)
    - [RAII概念](#raii概念)
    - [区分类型转换函数和转换构造函数,explicit](#区分类型转换函数和转换构造函数explicit)
    - [mutable关键字](#mutable关键字)
    - [c++11 新特性 memory model](#c11-新特性-memory-model)
    - [c++11 新特性 左值右值(lvalue xvalue prvalue)](#c11-新特性-左值右值lvalue-xvalue-prvalue)
    - [c++11 转移拷贝和转移构造，](#c11-转移拷贝和转移构造)
    - [c++11 =default =delete修饰assginment/copy construtor](#c11-default-delete修饰assginmentcopy-construtor)
    - [static_cast等](#static_cast等)
    - [智能指针](#智能指针)
    - [虚拟继承](#虚拟继承)
    - [local static 对象与non local static对象](#local-static-对象与non-local-static对象)
    - [为何需要虚析构函数?](#为何需要虚析构函数)
    - [c++11 构造和析构期间不用虚函数](#c11-构造和析构期间不用虚函数)
    - [接口设计易用](#接口设计易用)
    - [类型转换函数](#类型转换函数)

<!-- /TOC -->

# 要点

## 类型提升规则
![Screenshot from 2019-05-24 09-55-22-eccfa287-4a37-49d6-9ddc-cc617a1d02df](https://images-1257933000.cos.ap-chengdu.myqcloud.com/Screenshot%20from%202019-05-24%2009-55-22-eccfa287-4a37-49d6-9ddc-cc617a1d02df.png)

值得注意的是unsigned int + int , int提升为unsigned int;

## 引用与const引用
引用即别名. 绑定的对象不能再换其他的对象，但是对象的值可以被改变.
```cpp
int big = 1;
	int small = 2;
	int & ret = big;
	//常量引用　有点像const char * const 指针
	const unsigned char & uc_ref = (small + big);
	const char & c_ref = (small + big);
	const int & i_ref = (small + big);
	//fail
	//c_ref = small;
	ret = small;
	//发生了隐式转换，常量引用绑定在临时值，但是临时值消失了
	std::cout << "const ref convert to tmp char:" << c_ref << std::endl;
	std::cout << "const ref convet to tmp unsigned char:" << uc_ref << std::endl;
	std::cout << "const ref no convert " << i_ref << std::endl;
	std::cout << ret << std::endl;
```
不想改变?`const int &`,常量引用即可.

普通引用只能绑定左值,意思是=右边的是必须在内存里一直存放的,不能是临时的.

但是常量引用比较厉害，左值右值都行.

## c++11 constexpr

常量表达式
<https://blog.csdn.net/qq_37568748/article/details/82287153>

* 变量
将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化，否则编译器将报错


## const修饰的位置
const修饰返回值;
const修饰函数参数;
const修饰成员函数;

## struct 与class区别

## auto
编译器推断后的类型不一定等于原来的类型;
```cpp
const int i = 10;
int & j = i;
auto a = j; // auto不是引用　而是int类型
auto b = i ; //是int const被拿掉.
const auto c = i; //保留const的做法
auto & d = j; //这是保留引用的做法
```

## decltype 
```cpp
decltype(f()) sum = x;// sum的类型就是f的返回类型
int a = 10;
int & c = a;
decltype(a)  aa ; //指定类型推断
decltype(c)  cc = 100; //与auto不同，原来c是什么类型，cc就是什么类型，这里是引用，因此需要初始化
decltype((a)) aaa = 100; //()起来的变量，被decltype得到的是引用类型.
```
用于函数指针比较清晰:

先看c语言的, 来个函数指针，参数也是函数指针，返回也是函数指针?
```c
    void (*signal)( void (*handler)(int,char), int)(int, char);
```
signal函数接收两个参数:
1 void (*)(int,char)的函数指针 hander. 
2 in2
返回的也是函数参数指针: void (*)(int ,char);

如果某个函数需要返回signal函数呢?..很绕了.
如果用decltype:
```c
//很简洁的
decltype(signal) * someFunction(int i){...};
```

## c++11 委托构造函数
```
class A {
public:
    A(const std::string & name, int size, int type ):
    _name(name),_size(size),_type(type)
    {}
    //把构造函数委托给另外1个构造函数
    A(const std::string & name): A(name,100,1) {}
    A(int size): A("good",size,1) {}
private:
    const std::string & _name;
    int _size;
    int _type;
}
```

## c++初始化列表
类成员初始化最好用它，避免一次默认构造.
## RAII概念
“Resource Acquisition is Initialization”
in effectivec++ item15:
1.如果自己构造函数中申请分配资源，在析构函数中释放资源.
2.智能指针包裹资源，资源交给它来管理,就是引用计数.
注意:
* copy RAII对象最好禁止
不管复制多少个，希望最好1个释放的时候，资源即释放.
* 不好禁止的话,将资源用智能指针包裹，即引用计数的方式
## 区分类型转换函数和转换构造函数,explicit
转换构造是构造函数，参数只有1个构造函数，将其他类转成本类,一般是隐式转换.

类型转换函数是将类型转换为数据
```cpp
class A {
pubic:
    int _a;
    //转换构造　
    A(int a) {
        _a = a;
    }
    //类型转换
    operator double() {
        return double(_a);
    }
}

A obj = 10; //ok发生了上面的隐式构造转换.
obj._a ; //10

//fail if explicit
A obj = 10;
//ok if explicit and static_cast
A obj  = static_cast<A>(10);
```
* explict关键字
声明转换构造函数为explict,明确告诉编译器禁止这种隐式转换行为.
`explicit关键字只对有一个参数的类构造函数有效`.
规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。
除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit.

## mutable关键字
```cpp
class A{
    sth(){
        b++;
    } const;
    mutable private int b;
}
```
`const后缀修饰的成员函数`不可改变成员的状态，但是`mutable`修饰的成员例外.
## c++11 新特性 memory model
<https://www.zhihu.com/question/24301047>
//tbd

## c++11 新特性 左值右值(lvalue xvalue prvalue)
左值：会分配内存，右边可用=号.
右值：临时对象，表达式结束后，对象销毁.
```cpp
i++; //先使用i再+,不能再=了，右值
++i; //先加再用i,++i=1; ok,左值
func(xx); //函数返回值若不是引用，右值
```
c++11引入了所谓xvalue，下面3种情况会产生：
```sh
返回T&& 的函数或者运算重载
static_cast<char&&>(x).
std::move(x).
```
它的作用是Hold住临时值，别急着释放，重复利用，提高效率!
但是它仍具有右值的性质,如右边不能放=号..
如果是具名的右值引用，它只能绑定右值，包括prvalue和xvalue,
但其本身的表达式value cate为左值，(需要地方存放它!)
## c++11 转移拷贝和转移构造，
<https://blog.csdn.net/jisuanji198509/article/details/80652551>

```cpp
A a = A(1); //触发转移拷贝 if any.
A b;
b= A(1); //触发转义构造 if any.
```
## c++11 =default =delete修饰assginment/copy construtor


## static_cast等

<https://blog.csdn.net/q1n2hen/article/details/77994009>

dynamic_cast效率并不好.

const_cast破除const性质:
```cpp
const int a = 10;
a = 11;// no!
b = const_cast<int>(a);
b = 12;
```
reinterpret_cast主要用于为解释为不同类型的指针:
```cpp
int i = 0x12345678
int * a = &i;
char *b = reinterpret_cast<char*>a;
```

## 智能指针
RAII　auto_ptr, shared_ptr, unique_ptr, weak_ptr;
## 虚拟继承
解决菱形多继承问题.子类有2个ptr,1个指向子类新创建的virtual fun table,另1个指向虚基类table，实现共享基础类.
虚基类table存储的是，虚基类相对直接继承类的偏移.
<https://blog.csdn.net/bxw1992/article/details/77726390>
`virtual pubic` always比public 好？它能解决多重继承的菱形问题，但付出更多的空间代价和复杂度代价.

## local static 对象与non local static对象
见effective c+= item4.
`Singleton模式`的来源啊!回答: 为何需要1个静态变量,1个静态函数?
答:用static函数代替直接对static对象的使用，若直接用后者，后者可能还未初始化好!
放在static里，去new出来，保证该对象一定创建，而且可共享.
## 为何需要虚析构函数?
effectivec++ item7
为了防止派生类内存泄露:
```cpp
Base * ptr = &Child;
ptr->virtual_func();//
/*
1 .派生类申请了内存，在派生类的析构中释放.
2 .基类指针使用该派生类.
3 .delete ptr; 
    若无虚析构,此时调用的是Base:~Base();
    若有,则调用的是Child:~Child(),在~Child()里，又会调用Base():~Base()，才是正确的
*/
```
编译器默认不产生virtual ~Base()!,需要手动指定.
## c++11 构造和析构期间不用虚函数
effectivec++ item9: 不会有虚函数的效果, vptr都没初始化好呢.
## 接口设计易用
提供接口时，考虑使用者stupid.
工厂模式创建实例,good:
```cpp
Elem* createElement();
```
但是调用者用完后可能忘了delete,于是改成shared_ptr:
```cpp
std::shared_ptr<Elem> createElement();
```
## 类型转换函数
这些都很熟悉了:
```sh
default construtor
constructor
copy constructor
assignment copy constructor
destructor
```
类型转换是将1个类型转换成另外1个类型:
```cpp
class A {
    operator type( )
    {
        //实现转换的语句
    }
}

type t;
A() + t; //A()将执行类型转换变成type.
 ```
 ## throw
 ```sh
void fun() throw();      //表示fun函数不允许抛出任何异常，即fun函数是异常安全的。
void fun() throw(...);    //表示fun函数可以抛出任何形式的异常。
void fun() throw(exceptionType);    // 表示fun函数只能抛出exceptionType类型的异常。
 ```

 ## 传值和返回值
传参时，pass-by-value效率肯定没有pass-by-reference-const高.
但内置类型、迭代器、和函数对象除外，老实的pass-by-value也挺好.

返回时,除非特别有必要，采用return-by-value. return-by-reference并不是好想法.

## c++模板　全特化　偏特化
```cpp
template<class T,class N> 
class Template{}; 
 
//全特化:
template<>  class Template<int,char>{};
//偏特化：
template<class T> class Template<T,int>{};
 
```
注意：函数模版不存在偏特化，只有类模版才能偏特化

## swap对象
见<高效swap实现>

## stl algorithm
<https://blog.csdn.net/jerryjbiao/article/category/870957/2?>

## copy_and_swap策略
异常函数3个等级: 基本安全，强烈安全，不抛异常
copy_swap可基本实现`强烈安全`,但性能复出copy的代价.

## inline
对函数的调用用函数内容整体替换之，类似宏.

对象的构造析构等一般都不能inline,背后有复杂的异常处理.

nline函数不适合动态库，不利用升级.

## 再谈pimpl模式
通过定义private的对象指针(智能指针)，对引用和管理对象.
前面强调的是别的对象，实际将自身再抽离一层，也是有好处的.
见effectivec++ item31, 将编译依存关系将到最低.

对外是Person.
实现时，Person其实依赖PersonImple, PersonImple把包含其他对象的依赖(Date)

## 前向声明

见<pimple模式与前向声明>

## 函数对象

见<函数对象与bind>

## 名称空间的掩盖

public派生类的函数会掩盖基类的同名函数，包括重载版本.
要想不掩盖，需要在类定义显示声明`using Base::f()`或通过转交的形式:
```cpp
Derived {
    void f(){
        //显示调用Base::f();
        Base::f();
    }
}
```
## pure-virtual impure-vitual 和non-vitrual的选择
继承的2个功能: 接口继承和实现继承.
3类函数:
pure-vitual只是为让派生类继承接口;
non-vitrual是为了让派生类继承接口的功能(实现);
impure-virtual基于两者之间.(改写了是要接口，不改写时，是要默认的实现)

impure-virtual的最佳实践:
```cpp

class Base {
    virtual void fly() = 0;
};

class Child1: public Base {
} ;

class Child2: public Base {
} ;

void Base:fly(){
    //默认fly行为，纯虚函数的实现
};

void Child::fly(){
    //保持默认实现行为
    Base::fly();
}

void Child2::fly(){
    //自己的重写代码
}
```
## c++的模板方法设计模式
non-vitrual-interface(NVI)：
类实现提供non-virtual作为vitrual函数的wrapper
```cpp
class A {
public:
    int someThing() {
        //sth before
        int ret = my_virtual_funcion();
        //sth later
        return ret;
    }
    virtual void my_virtual_function();
}

```
这样对外继承接口的实现(someThing),单实际可通过(my_virtual_function)改写自己所需的函数功能.
好处:针对my_virtual_function实现一些固定的调用前(sth before)和调用后(sth after)的处理.

## 考虑单纯的虚函数以外的选择
```sh
模板方法(NVI)
桥接模式(引入某对象指针作为成员)
策略模式(引入某函数对象对位成员)
```

## 静态绑定与动态绑定
* 对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
* 对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
* 静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。
* 动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。
* 只有虚函数才使用的是动态绑定，其他的全部是静态绑定
`non-virtual函数才谈动态绑定!`

## 复合关系

1. has-a
这种关系一般位于具体应用的对象间,这些对象为`应用域`的.
```sh
Person has a Name.
Animal has a Tail
```
2. is-implemented-in-terms-of
纯粹的技术细节的人工制品, 这些对象为`实现域`的.
```sh
Mutex
Buffer,
Search Trees
```

## C++中static变量与继承

static内存独有１份，肯定父子是共享的，父亲可通过private声明是否共享.











